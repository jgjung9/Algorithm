/**
 * https://www.acmicpc.net/problem/11726
 * 
 * 처음 생각: 2 x 1 타일의 경우 그냥 빈곳에 넣으면 되지만 1 x 2 타일의 경우 한곳에 놓게 되면 무조건 2개를 놓아야 한다.
 * 1 x 2 타일의 모양이 나타날수 있는 케이스를 생각하는 방식으로 접근
 * 1 x 2 타일 2개 묶음을 b
 * 1 x 2 타일 2개 묶음을 a 라고 하면
 * 2 x 5 의 경우 
 * b가 한번 오면 aaab aaba abaa baaa의 경우로 나타낼수 있다
 * => 중복이 존재하는 수열로 생각할 수 있음
 * (a의 개수 + b의 개수)! / (a의 개수)! * (b의 개수)!
 * b의 개수를 0부터 가능한 개수까지 차례대로 증가시켜 최대치까지 계산하고 모두 더한 값이 정답이 됨
 * => 1000!까지 계산해야 하는 경우가 발생하고 이를 해결하기 위해 modular를 중간에 넣기에는
 * 너무 복잡한 과정 => 다른 방식 필요
 * 
 * hint: DP 방식으로 보다간단하게 해결가능
 * n = 1 인경우 dp[1] = 1
 * n = 2 인경우 dp[2] = 2
 * ...
 * dp[n] => 마지막에 놓은 타일이 1x2 , 2x1 경우가 두가지가 존재한다.
 * 1x2 인경우 dp[n-2]의 경우의 수가 앞에 올수 있고
 * 2x1 인경우 dp[n-1]의 경우의 수가 앞에 올수 있다.
 * ===> 즉 dp[n] = dp[n-1] + dp[n-2]가 된다.
 */

const fs = require('fs');
const input = +fs.readFileSync('./input.txt').toString().trim();

const dp = [0, 1, 2];
for (let i = 3; i <= input; i++) {
    dp.push((dp[i - 1] + dp[i - 2]) % 10007);
}

console.log(dp[input]);